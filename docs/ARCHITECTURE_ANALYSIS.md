# 10만~100만 토큰 처리 아키텍처 분석

## 1. 현재 구현의 한계점

### 1.1 현재 상태 (v2.0)

```
현재 구현:
┌─────────────────────────────────────────────────────────────┐
│  메시지 → Chunker(500토큰) → 백그라운드 요약 → SQLite 저장    │
│                                    ↓                        │
│                              MCP 도구로 조회                 │
└─────────────────────────────────────────────────────────────┘
```

**문제점:**

| 문제 | 설명 | 영향 |
|------|------|------|
| **수동 호출** | 오케스트라가 MCP 도구를 명시적으로 호출해야 함 | 자동화 불가 |
| **단방향 흐름** | 에이전트 → 오케스트라 방향 컨텍스트 주입 없음 | 컨텍스트 유실 |
| **단일 프로세스** | 요약이 순차적으로 처리됨 | 대규모 처리 병목 |
| **메모리 한계** | Node.js 힙 메모리 제한 (~4GB) | 100만 토큰 불가 |

### 1.2 실제 10만 토큰 처리 시나리오

```
10만 토큰 = 200개 청크 (500토큰/청크)
200개 청크 × 요약 시간 (2초/청크) = 400초 = 6.7분

문제: 
- 오케스트라(Claude Code)의 컨텍스트 윈도우는 200K
- 10만 토큰 대화 후 → 오케스트라 자체가 컨텍스트 초과
- 에이전트가 요약해도 오케스트라에 전달할 방법이 없음
```

### 1.3 핵심 질문: "누가 언제 압축을 트리거하는가?"

```
현재 (문제):
┌─────────────────────────────────────────────────────────────┐
│  오케스트라 (Claude Code)                                    │
│  ├─ 대화 진행... 진행... 진행...                             │
│  ├─ 컨텍스트 200K 도달                                       │
│  ├─ ❌ 자동 압축 (Claude 내장) → 세부사항 유실               │
│  └─ ❌ MCP 호출 잊음 → 에이전트 메모리 미사용                │
└─────────────────────────────────────────────────────────────┘

이상적 (목표):
┌─────────────────────────────────────────────────────────────┐
│  오케스트라 (Claude Code)                                    │
│  ├─ 대화 진행...                                             │
│  ├─ 50K 토큰 도달 (임계값)                                   │
│  ├─ ✅ 자동으로 에이전트에 컨텍스트 위임                     │
│  ├─ ✅ 에이전트가 압축 후 요약 반환                          │
│  └─ ✅ 오케스트라가 요약으로 컨텍스트 교체                   │
└─────────────────────────────────────────────────────────────┘
```

---

## 2. 실제 동작 가능한 아키텍처

### 2.1 오케스트라-에이전트-MCP-CLI 협력 구조

```
┌─────────────────────────────────────────────────────────────────────────┐
│                        ORCHESTRATOR (Claude Code / OpenCode)            │
│  ┌───────────────────────────────────────────────────────────────────┐  │
│  │  System Prompt에 주입:                                            │  │
│  │  "매 응답 전 memory_should_compress 호출하여 압축 필요 여부 확인"  │  │
│  │  "압축 필요 시 memory_get_context로 압축된 컨텍스트 로드"          │  │
│  └───────────────────────────────────────────────────────────────────┘  │
│                                    │                                    │
│                                    ▼                                    │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │                         MCP PROTOCOL                             │   │
│  │  ┌─────────────┐  ┌─────────────┐  ┌─────────────────────────┐  │   │
│  │  │ Tool Call   │  │ Tool Result │  │ Resource (컨텍스트)      │  │   │
│  │  │ (요청)      │→ │ (응답)      │  │ (cache_prefix 주입)     │  │   │
│  │  └─────────────┘  └─────────────┘  └─────────────────────────┘  │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                    │                                    │
└────────────────────────────────────┼────────────────────────────────────┘
                                     │
                                     ▼
┌─────────────────────────────────────────────────────────────────────────┐
│                        AGENT (Conversation Memory V2)                   │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │                      MCP SERVER (stdio)                          │   │
│  │  ┌─────────────────────────────────────────────────────────┐    │   │
│  │  │  도구 목록:                                              │    │   │
│  │  │  - memory_should_compress: 압축 필요 여부 판단           │    │   │
│  │  │  - memory_add_message: 메시지 저장 (자동 청킹)           │    │   │
│  │  │  - memory_get_context: 압축된 컨텍스트 반환              │    │   │
│  │  │  - memory_search: 과거 대화 검색                         │    │   │
│  │  │  - memory_get_stats: 토큰 사용량/압축률 통계             │    │   │
│  │  └─────────────────────────────────────────────────────────┘    │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                    │                                    │
│                                    ▼                                    │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │                      CORE ENGINE                                 │   │
│  │  ┌───────────┐  ┌───────────┐  ┌───────────┐  ┌─────────────┐  │   │
│  │  │  Chunker  │  │  Indexer  │  │  Merger   │  │   Worker    │  │   │
│  │  │ (500토큰) │→ │ (태그)    │→ │ (병합)    │← │ (비동기)    │  │   │
│  │  └───────────┘  └───────────┘  └───────────┘  └─────────────┘  │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                    │                                    │
│                                    ▼                                    │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │                      STORAGE LAYER                               │   │
│  │  ┌─────────────────────┐  ┌─────────────────────────────────┐  │   │
│  │  │  SQLite + FTS5      │  │  LLM Provider (OpenRouter)       │  │   │
│  │  │  (영구 저장)        │  │  (요약 생성)                     │  │   │
│  │  └─────────────────────┘  └─────────────────────────────────┘  │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                    │                                    │
└────────────────────────────────────┼────────────────────────────────────┘
                                     │
                                     ▼
┌─────────────────────────────────────────────────────────────────────────┐
│                              CLI                                        │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │  conv-memory serve     → MCP 서버 시작                          │   │
│  │  conv-memory start     → 새 대화 시작                           │   │
│  │  conv-memory context   → 압축된 컨텍스트 출력                   │   │
│  │  conv-memory search    → 과거 대화 검색                         │   │
│  │  conv-memory export    → 전체 대화 내보내기                     │   │
│  └─────────────────────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────────────────────┘
```

### 2.2 10만 토큰 처리 흐름

```
시간 →
┌────────────────────────────────────────────────────────────────────────┐
│ T=0: 대화 시작                                                         │
│ ┌──────────────────────────────────────────────────────────────────┐  │
│ │ 오케스트라: "프로젝트 시작"                                       │  │
│ │ → memory_add_message("user", "프로젝트 시작")                     │  │
│ │ → 에이전트: 버퍼에 저장 (8 토큰)                                  │  │
│ └──────────────────────────────────────────────────────────────────┘  │
├────────────────────────────────────────────────────────────────────────┤
│ T=1~100: 대화 진행 (50K 토큰 누적)                                     │
│ ┌──────────────────────────────────────────────────────────────────┐  │
│ │ 오케스트라: 계속 대화...                                          │  │
│ │ → 에이전트: 100개 청크 생성, 백그라운드 요약 진행                 │  │
│ │ → 에이전트: 요약 완료된 청크들 병합 (5개 단위)                    │  │
│ │ → 에이전트: 병합 컨텍스트 20개 생성                               │  │
│ └──────────────────────────────────────────────────────────────────┘  │
├────────────────────────────────────────────────────────────────────────┤
│ T=101: 압축 트리거 (50K 임계값 도달)                                   │
│ ┌──────────────────────────────────────────────────────────────────┐  │
│ │ 오케스트라: memory_should_compress() 호출                         │  │
│ │ → 에이전트: { shouldCompress: true, currentTokens: 50000 }        │  │
│ │                                                                   │  │
│ │ 오케스트라: memory_get_context() 호출                             │  │
│ │ → 에이전트: 병합된 컨텍스트 반환 (5K 토큰)                        │  │
│ │                                                                   │  │
│ │ 오케스트라: 기존 대화 기록 삭제, 압축 컨텍스트로 교체             │  │
│ │ → 컨텍스트: 50K → 5K (90% 압축)                                   │  │
│ └──────────────────────────────────────────────────────────────────┘  │
├────────────────────────────────────────────────────────────────────────┤
│ T=102~200: 대화 계속 (추가 50K 토큰)                                   │
│ ┌──────────────────────────────────────────────────────────────────┐  │
│ │ 오케스트라: 계속 대화... (현재 컨텍스트: 5K + 새 대화)            │  │
│ │ → 에이전트: 추가 100개 청크 생성, 요약 진행                       │  │
│ │ → 에이전트: 기존 병합 컨텍스트와 새 요약 재병합                   │  │
│ └──────────────────────────────────────────────────────────────────┘  │
├────────────────────────────────────────────────────────────────────────┤
│ T=201: 두 번째 압축 트리거                                             │
│ ┌──────────────────────────────────────────────────────────────────┐  │
│ │ 오케스트라: memory_should_compress() → true                       │  │
│ │ → 에이전트: 전체 100K 토큰 → 8K 토큰으로 압축                     │  │
│ │ → 오케스트라: 컨텍스트 교체                                       │  │
│ └──────────────────────────────────────────────────────────────────┘  │
└────────────────────────────────────────────────────────────────────────┘

결과: 100K 토큰 대화 → 8K 토큰 컨텍스트 (92% 압축)
      세부 결정사항, 코드, 태그 모두 보존
```

### 2.3 100만 토큰 처리 전략

```
100만 토큰 = 2000개 청크 = 400개 병합 컨텍스트

문제: 단일 프로세스로 2000개 청크 요약 = 4000초 = 1.1시간

해결: 병렬 비동기 처리 + 계층적 요약

┌─────────────────────────────────────────────────────────────────────────┐
│                      계층적 요약 아키텍처                               │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  Level 0 (원본):     [500토큰] × 2000개 = 100만 토큰                    │
│                           ↓ (병렬 요약 × 20 workers)                    │
│  Level 1 (청크요약): [150토큰] × 2000개 = 30만 토큰                     │
│                           ↓ (5개씩 병합)                                │
│  Level 2 (병합):     [500토큰] × 400개 = 20만 토큰                      │
│                           ↓ (5개씩 병합)                                │
│  Level 3 (재병합):   [800토큰] × 80개 = 6.4만 토큰                      │
│                           ↓ (5개씩 병합)                                │
│  Level 4 (최종):     [1200토큰] × 16개 = 1.9만 토큰                     │
│                                                                         │
│  최종 압축률: 100만 → 1.9만 = 98% 압축                                  │
│  처리 시간: 2000개 / 20 workers × 2초 = 200초 = 3.3분                   │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

---

## 3. 핵심 해결책: 자동 컨텍스트 주입

### 3.1 문제: MCP는 "요청-응답" 모델

```
현재 MCP 한계:
- 오케스트라가 도구를 호출해야만 에이전트가 응답
- 에이전트가 먼저 오케스트라에 데이터를 푸시할 수 없음
- 오케스트라가 memory_get_context를 호출하지 않으면 압축 컨텍스트 미사용
```

### 3.2 해결책 1: System Prompt 주입 (권장)

```markdown
# Claude Code / OpenCode System Prompt에 추가

## 메모리 관리 규칙

1. **매 응답 전** `memory_should_compress` 도구를 호출하여 압축 필요 여부 확인
2. 압축이 필요하면 (`shouldCompress: true`):
   - `memory_get_context` 호출하여 압축된 컨텍스트 획득
   - 이전 대화 기록을 압축 컨텍스트로 교체
3. **모든 메시지**는 `memory_add_message`로 에이전트에 저장
4. 과거 내용 필요 시 `memory_search`로 검색

이 규칙은 장기 프로젝트의 컨텍스트 연속성을 위해 필수입니다.
```

### 3.3 해결책 2: CLAUDE.md 파일 (Claude Code 전용)

```markdown
# CLAUDE.md (프로젝트 루트에 배치)

## Memory Management

This project uses Conversation Memory V2 for context management.

### Required Actions

Before each response:
1. Call `memory_should_compress` to check if compression is needed
2. If `shouldCompress` is true, call `memory_get_context` and use the compressed context
3. Always call `memory_add_message` to save your response

### Search Past Conversations

When you need information from previous sessions:
- Use `memory_search` with relevant keywords
- The system maintains full conversation history across sessions
```

### 3.4 해결책 3: MCP Resource (고급)

```typescript
// MCP Resource를 통한 자동 컨텍스트 제공
// 오케스트라가 리소스를 구독하면 자동으로 컨텍스트 업데이트

server.setRequestHandler(ListResourcesRequestSchema, async () => ({
  resources: [{
    uri: "memory://context/current",
    name: "Current Compressed Context",
    description: "Auto-updated compressed conversation context",
    mimeType: "application/json"
  }]
}));

server.setRequestHandler(ReadResourceRequestSchema, async (request) => {
  if (request.params.uri === "memory://context/current") {
    const context = await memory.getContext();
    return {
      contents: [{
        uri: request.params.uri,
        mimeType: "application/json",
        text: JSON.stringify(context)
      }]
    };
  }
});
```

---

## 4. 실제 구현 계획

### 4.1 Phase 1: 자동 압축 트리거 (필수)

```typescript
// 새로운 MCP 도구: memory_should_compress
{
  name: "memory_should_compress",
  description: "압축 필요 여부를 확인합니다. 매 응답 전 호출 권장.",
  inputSchema: {},
  handler: async () => {
    const stats = await memory.getStats();
    const threshold = 50000; // 50K 토큰
    return {
      shouldCompress: stats.currentTokens > threshold,
      currentTokens: stats.currentTokens,
      compressedTokens: stats.compressedTokens,
      compressionRatio: stats.compressionRatio
    };
  }
}
```

### 4.2 Phase 2: 병렬 요약 워커 (성능)

```typescript
// 병렬 요약을 위한 워커 풀
class ParallelSummarizer {
  private workerPool: Worker[] = [];
  private maxWorkers = 20;

  async summarizeChunks(chunks: Chunk[]): Promise<Summary[]> {
    const batchSize = Math.ceil(chunks.length / this.maxWorkers);
    const batches = this.splitIntoBatches(chunks, batchSize);
    
    // 병렬 처리
    const results = await Promise.all(
      batches.map(batch => this.processBatch(batch))
    );
    
    return results.flat();
  }
}
```

### 4.3 Phase 3: 계층적 병합 (대규모)

```typescript
// 계층적 병합 전략
class HierarchicalMerger {
  async merge(summaries: Summary[], targetTokens: number): Promise<MergedContext> {
    let current = summaries;
    let level = 0;
    
    while (this.getTotalTokens(current) > targetTokens) {
      current = await this.mergeLevel(current, 5); // 5개씩 병합
      level++;
    }
    
    return {
      level,
      contexts: current,
      totalTokens: this.getTotalTokens(current)
    };
  }
}
```

---

## 5. 결론: 실제 가능한가?

### 5.1 10만 토큰: ✅ 가능

| 항목 | 현재 | 개선 후 |
|------|------|---------|
| 처리 시간 | 6.7분 | 30초 (병렬화) |
| 압축률 | 80% | 90%+ |
| 자동화 | 수동 | System Prompt로 자동 |

### 5.2 100만 토큰: ⚠️ 조건부 가능

| 조건 | 필요 사항 |
|------|----------|
| 병렬 워커 | 20개 이상 동시 요약 |
| 계층적 병합 | 4단계 이상 병합 |
| 스트리밍 | 청크 단위 점진적 처리 |
| 분산 저장 | SQLite → PostgreSQL 또는 분산 DB |

### 5.3 핵심 요구사항

```
1. 오케스트라 협력: System Prompt에 메모리 관리 규칙 주입 필수
2. 자동 트리거: memory_should_compress 도구 추가
3. 병렬 처리: 워커 풀로 요약 병렬화
4. 계층적 병합: 대규모 토큰 처리를 위한 다단계 병합
```

---

*분석 일자: 2025-01-09*
